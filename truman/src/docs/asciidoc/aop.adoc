[#aop]
= AOP
include::{includedir}/_attributes.adoc[]

[{java_src_attr}]
----
include::{aop_src_dir}/Advisor.java[]
----

include::{includedir}/aop-process-overview.adoc[leveloffset=+1]

include::{includedir}/aop-bootstrap.adoc[leveloffset=+1]

include::{includedir}/aop-get-advices.adoc[leveloffset=+1]

include::{includedir}/aop-create-proxy-jdk.adoc[leveloffset=+1]

include::{includedir}/aop-create-proxy-cglib.adoc[leveloffset=+1]

plantuml::{includedir}/puml/org.springframework.aop.MethodMatcher.puml[{diagram_attr}]

== `PointcutAdvisor`

plantuml::{includedir}/puml/org.springframework.aop.PointcutAdvisor.puml[{diagram_attr}]

`org.springframework.aop.PointcutAdvisor` 才是真正的定义一个 `Pointcut` 和一个 `Advice` 的 `Advisor`。

`DefaultPointcutAdvisor` 是最通用的 `PointcutAdvisor` 实现。

`NameMatchMethodPointcutAdvisor` 是细化后的 `DefaultPointcutAdvisor`。

`IntroductionAdvisor` 与 `PointcutAdvisor` 最本质的区别是 `IntroductionAdvisor` 只能应用于类级别的拦截，只能使用 Introduction 型的 `Advisor`。

`Ordered` 接口用于指定 Bean 的优先级。数字越小，优先级越高。

== Spring AOP 的织入

`ProxyFactory` 是最基本的一个织入器实现。 `ProxyFactory` 只需要指定如下两个最基本的东西：

. 对其要进行织入的目标对象。
. 将要应用到目标对象的 Aspect。在 Spring 里面叫做 Advisor。

[{java_src_attr}]
----
include::{truman_src_dir}/aop/ProxyFactoryTest.java[]
----

Spring AOP 框架使用 `AopProxy` 对使用的不同的代理实现机制进行了适度的抽象，针对不同的代理实现机制提供相应的 `AopProxy` 子类实现。目前提供了针对 JDK 的动态代理和 CGLIB 字节码增强两种机制的 `AopProxy` 实现。

plantuml::{includedir}/puml/AopProxy.puml[{diagram_attr}]

不同 `AopProxy` 实现的实例化过程采用工厂模式（确切地说是抽象工厂模式）进行封装，即通过 `org.springframework.aop.framework.AopProxyFactory` 创建 `AopProxy` 实例。

`AdvisedSupport` 就是一个生成代理对象所需要的信息的载体。

plantuml::{includedir}/puml/ProxyFactory.puml[{diagram_attr}]

`ProxyFactory` 集 `AopProxy` 和 `AdvisedSupport` 于一身，可以通过 `ProxyFactory` 设置生成代理对象所需要的相关信息，也可以通过 `ProxyFactory` 取得最终生成的代理对象。前者是 `AdvisedSupport` 的职责，后者是 `AopProxy` 的职责。

`ProxyFactory` 只是 Spring AOP 中最基本的织入器实现，还有其他的几个 "兄弟"：

plantuml::{includedir}/puml/ProxyCreatorSupport.puml[{diagram_attr}]


AOP 调试实例：

[{java_src_attr}]
----
include::{truman_src_dir}/aop/AopTest.java[]
----

plantuml::{includedir}/puml/org.springframework.aop.Pointcut.puml[{diagram_attr}]

`ComposablePointcut` 是 Spring AOP 提供可以进行 `Pointcut` 逻辑运算的 `Pointcut` 实现。

`ControlFlowPointcut` 是在某个类调动时拦截，其他类调用时不调用。每次运行都需要做检查，性能差，慎重选择。

感觉 `Advisor` 和 `Advice` 表示的意思是一样的。不一样的是 `Advisor` 是 Spring 自己创建的； `Advice` 是 AOP Alliance 定义的。两者的包不一样。

`ReflectiveMethodInvocation.currentInterceptorIndex` 如果一个实例被多次调用，怎么来维护这个属性？每次调用方法，都会创建一个 `CglibMethodInvocation` 或者 `ReflectiveMethodInvocation`，这样每次 `currentInterceptorIndex` 属性都是从初始化开始的。

使用 JDK 动态代理生成代理类时，如果多个接口，生成代理时，如何选择？没有被选中的接口怎么办？

在 `expose-proxy = true` 使用 `((UserService) AopContext.currentProxy())` 代替 `this`，就可以获取代理类。

多个 AOP 增强怎么处理？

`SyntheticInstantiationAdvisor` 是干什么的？

当 `BeanDefinition` 中有 `RuntimeBeanReference` 属性时，就会触发 `org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary`，从 `populateBean` → `applyPropertyValues` → `resolveValueIfNecessary`。

跟踪代码发现， `RuntimeBeanReference` 类型的依赖关系最后会像 `dependsOn` 属性那样，注册到 `dependentBeanMap` 和 `dependenciesForBeanMap` 属性中。



`com.alibaba.spring.beans.factory.annotation.EnableConfigurationBeanBindings` 这是什么鬼？干啥的？ -- 将基于proprieties 文件的配置项和对应的 Bean 建立起关联关系。


这是什么？


AOP 如何实现几种不同的通知的？怎么一步一步调用下去？怎么保存现场？

Spring 中不同 Aspect 直接是如何排序的？如何实现在前置通知和后置通知在正确位置执行？

include::{includedir}/template-method-pattern.adoc[leveloffset=+1]

include::{includedir}/proxy-pattern.adoc[leveloffset=+1]

include::{includedir}/dynamic-proxy.adoc[leveloffset=+1]

include::{includedir}/aspectj-intro.adoc[leveloffset=+1]
