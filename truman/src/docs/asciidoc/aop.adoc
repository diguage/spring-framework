[#aop]
= AOP
include::{includedir}/_attributes.adoc[]

[{java_src_attr}]
----
include::{aop_src_dir}/Advisor.java[]
----

include::{includedir}/aop-process-overview.adoc[leveloffset=+1]

include::{includedir}/aop-bootstrap.adoc[leveloffset=+1]

include::{includedir}/aop-get-advices.adoc[leveloffset=+1]

include::{includedir}/aop-create-proxy-jdk.adoc[leveloffset=+1]

include::{includedir}/aop-create-proxy-cglib.adoc[leveloffset=+1]

plantuml::{includedir}/puml/org.springframework.aop.MethodMatcher.puml[{diagram_attr}]

== `PointcutAdvisor`

plantuml::{includedir}/puml/org.springframework.aop.PointcutAdvisor.puml[{diagram_attr}]

`org.springframework.aop.PointcutAdvisor` 才是真正的定义一个 `Pointcut` 和一个 `Advice` 的 `Advisor`。

`DefaultPointcutAdvisor` 是最通用的 `PointcutAdvisor` 实现。

`NameMatchMethodPointcutAdvisor` 是细化后的 `DefaultPointcutAdvisor`。

`IntroductionAdvisor` 与 `PointcutAdvisor` 最本质的区别是 `IntroductionAdvisor` 只能应用于类级别的拦截，只能使用 Introduction 型的 `Advisor`。

`Ordered` 接口用于指定 Bean 的优先级。数字越小，优先级越高。

== Spring AOP 的织入

`ProxyFactory` 是最基本的一个织入器实现。 `ProxyFactory` 只需要指定如下两个最基本的东西：

. 对其要进行织入的目标对象。
. 将要应用到目标对象的 Aspect。在 Spring 里面叫做 Advisor。

[{java_src_attr}]
----
include::{truman_src_dir}/aop/ProxyFactoryTest.java[]
----

Spring AOP 框架使用 `AopProxy` 对使用的不同的代理实现机制进行了适度的抽象，针对不同的代理实现机制提供相应的 `AopProxy` 子类实现。目前提供了针对 JDK 的动态代理和 CGLIB 字节码增强两种机制的 `AopProxy` 实现。

plantuml::{includedir}/puml/AopProxy.puml[{diagram_attr}]

不同 `AopProxy` 实现的实例化过程采用工厂模式（确切地说是抽象工厂模式）进行封装，即通过 `org.springframework.aop.framework.AopProxyFactory` 创建 `AopProxy` 实例。

`AdvisedSupport` 就是一个生成代理对象所需要的信息的载体。

plantuml::{includedir}/puml/ProxyFactory.puml[{diagram_attr}]

`ProxyFactory` 集 `AopProxy` 和 `AdvisedSupport` 于一身，可以通过 `ProxyFactory` 设置生成代理对象所需要的相关信息，也可以通过 `ProxyFactory` 取得最终生成的代理对象。前者是 `AdvisedSupport` 的职责，后者是 `AopProxy` 的职责。

`ProxyFactory` 只是 Spring AOP 中最基本的织入器实现，还有其他的几个 "兄弟"：

plantuml::{includedir}/puml/ProxyCreatorSupport.puml[{diagram_attr}]

Spring AOP 的自动代理的实现建立在 IoC 容器的 `BeanPostProcessor` 概念之上。只要提供一个 `BeanPostProcessor`，当对象实例化的时候，为其生成代理对象返回，而不是实例化后的目标对象本身，从而达到代理对象自动生成的目的。伪代码如下：

[{java_src_attr}]
----
for (bean in container) {
    if (检查当前 bean 定义是否符合拦截条件；如果符合拦截条件，则) {
        Object proxy = createProxyFor(bean);
        return proxy;
    } 否则 {
        Object instance = createInstance(bean);
        return instance;
    }
}
----

检查当前 bean 是否符合拦截条件，首先需要知道拦截条件是什么？我们通过某种方式，告知自动代理实现类都有哪些拦截条件：

. 通过外部配置文件传入；
. 在具体类的元数据来指明。

`BeanNameAutoProxyCreator` 通过指定一组容器内的目标对象对应的 `beanNames`，将指定的一组拦截器应用到这些目标对象之上。

将 `DefaultAdvisorAutoProxyCreator` 注册到容器后，它会自动搜寻容器内的所有 `Advisor`，然后根据各个 `Advisor` 所提供的拦截信息，为符合条件的容器中的目标对象生成相应的代理对象。为了避免将不必要的横切逻辑织入到不需要的目标对象之上，应该尽量细化各个 `Advisor` 的定义。

`InstantiationAwareBeanPostProcessor` 有 "短路" 功能。

`TargetSource` 最主要的特性是，每次方法调用都会触发 `TargetSource` 的 `getTarget()` 方法， `getTarget()` 方法将从相应的 `TargetSource` 实现类中取得具体的目标对象，这样就可以控制每次方法调用作用到的具体实例对象。

使用 `HotSwappableTargetSource` 封装目标对象，可以在应用程序运行时，根据某种特定条件，动态地替换目标对象类的具体实现。受此启发，可以实现一个根据配置动态切换数据源的透明数据源代理。代码如下：

[{java_src_attr}]
----
include::{truman_src_dir}/aop/HotSwappableTargetSourceXmlTest.java[]
----

XML 配置文件如下：

[{xml_src_attr}]
----
include::{truman_resource_dir}/aop/HotSwappableTargetSource.xml[]
----

TODO 改写成 JavaConfig 格式的

[{java_src_attr}]
----
include::{truman_src_dir}/aop/HotSwappableTargetSourceTest.java[]
----

`@Aspect` 注解中的 `value` 属性不能随便填写，否则会报错。该注解解析过程见 `org.aspectj.internal.lang.reflect.AjTypeImpl.getPerClause`。这是 “Aspect Instantiation Models”。Spring 目前只支持 `perthis` 和 `pertarget` 两种模式，其他模式不支持。

AOP 调试实例：

[{java_src_attr}]
----
include::{truman_src_dir}/aop/AopTest.java[]
----

plantuml::{includedir}/puml/org.springframework.aop.Pointcut.puml[{diagram_attr}]

`ComposablePointcut` 是 Spring AOP 提供可以进行 `Pointcut` 逻辑运算的 `Pointcut` 实现。

`ControlFlowPointcut` 是在某个类调动时拦截，其他类调用时不调用。每次运行都需要做检查，性能差，慎重选择。

感觉 `Advisor` 和 `Advice` 表示的意思是一样的。不一样的是 `Advisor` 是 Spring 自己创建的； `Advice` 是 AOP Alliance 定义的。两者的包不一样。

`ReflectiveMethodInvocation.currentInterceptorIndex` 如果一个实例被多次调用，怎么来维护这个属性？每次调用方法，都会创建一个 `CglibMethodInvocation` 或者 `ReflectiveMethodInvocation`，这样每次 `currentInterceptorIndex` 属性都是从初始化开始的。

使用 JDK 动态代理生成代理类时，如果多个接口，生成代理时，如何选择？没有被选中的接口怎么办？

在 `expose-proxy = true` 使用 `((UserService) AopContext.currentProxy())` 代替 `this`，就可以获取代理类。

多个 AOP 增强怎么处理？

`SyntheticInstantiationAdvisor` 是干什么的？

当 `BeanDefinition` 中有 `RuntimeBeanReference` 属性时，就会触发 `org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary`，从 `populateBean` → `applyPropertyValues` → `resolveValueIfNecessary`。

跟踪代码发现， `RuntimeBeanReference` 类型的依赖关系最后会像 `dependsOn` 属性那样，注册到 `dependentBeanMap` 和 `dependenciesForBeanMap` 属性中。



`com.alibaba.spring.beans.factory.annotation.EnableConfigurationBeanBindings` 这是什么鬼？干啥的？ -- 将基于proprieties 文件的配置项和对应的 Bean 建立起关联关系。


这是什么？


AOP 如何实现几种不同的通知的？怎么一步一步调用下去？怎么保存现场？

Spring 中不同 Aspect 直接是如何排序的？如何实现在前置通知和后置通知在正确位置执行？

include::{includedir}/template-method-pattern.adoc[leveloffset=+1]

include::{includedir}/proxy-pattern.adoc[leveloffset=+1]

include::{includedir}/dynamic-proxy.adoc[leveloffset=+1]

include::{includedir}/aspectj-intro.adoc[leveloffset=+1]
