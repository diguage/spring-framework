= Spring 源码分析

== 资源加载

`ResourceLoader` 也是一种策略模式，加载资源的策略。

[plantuml, format=svg,align="center",width=100%]
....
@startuml
title <b>Resource 与 ResourceLoader</b>

interface InputStreamSource {
	+InputStream getInputStream()
}

interface Resource extends InputStreamSource

interface ResourceLoader {
	+{static} String CLASSPATH_URL_PREFIX = "classpath:"

	+Resource getResource(String location)
	+ClassLoader getClassLoader()
}

note left of ResourceLoader : 加载单个 Resource

class DefaultResourceLoader implements ResourceLoader
class FileSystemResourceLoader extends DefaultResourceLoader

interface ResourcePatternResolver extends ResourceLoader {
	+{static} CLASSPATH_ALL_URL_PREFIX = "classpath*:"

	+Resource[] getResources(String locationPattern)
}

class PathMatchingResourcePatternResolver implements ResourcePatternResolver

note right of ResourcePatternResolver : 可以批量加载\nResource

ResourceLoader *- Resource
@enduml
....

`classpath*:` 与 `classpath:` 的唯一区别就在于，如果能够在 classpath 中找到多个指定的资源，则返回多个。


`ApplicationContext` 继承了 `ResourcePatternResolver`，当 然就间接实现了 `ResourceLoader` 接口。所以，任何的 `ApplicationContext` 实现都可以看作是一个 `ResourceLoader` 甚至 `ResourcePatternResolver`。而这就是 `ApplicationContext` 支持 Spring 内统一资源加载策略的真相。

[plantuml, format=svg,align="center",width=100%]
....
@startuml
title <b>ResourceLoader 与 ApplicationContext</b>

interface ResourceLoader

note right of ResourceLoader : 加载单个 Resource

class DefaultResourceLoader implements ResourceLoader

interface ResourcePatternResolver extends ResourceLoader

class PathMatchingResourcePatternResolver implements ResourcePatternResolver

'note right of ResourcePatternResolver : 可以批量加载\nResource

interface ApplicationContext extends ResourcePatternResolver
interface ConfigurableApplicationContext extends ApplicationContext
abstract class AbstractApplicationContext implements ConfigurableApplicationContext

abstract class AbstractApplicationContext extends DefaultResourceLoader {
    - resourcePatternResolver:ResourcePatternResolver
}

AbstractApplicationContext *--> PathMatchingResourcePatternResolver : has a >

@enduml
....

`AbstractApplicationContext` 继承了 `DefaultResourceLoader`，那么，它的 `getResource(String)` 当然就直接用 `DefaultResourceLoader` 的了。

`AbstractApplicationContext` 类的内 部声明有一个 `resourcePatternResolver`，类型是 `ResourcePatternResolver`，对应的实例类型为 `PathMatchingResourcePatternResolver`。

`ApplicationContext` 的实现类在作为 `ResourceLoader` 或者 `ResourcePatternResolver` 时候的行为，完全就是委派给了 `PathMatchingResourcePatternResolver` 和 `DefaultResourceLoader` 来做。

== I18n

properties 文件内容是以 ISO-8859-1 编码的。所以，不支持中文，需要把中文进行转码。

[plantuml, format=svg,align="center",width=100%]
....
@startuml
title <b>MessageSource类层次结构</b>

interface HierarchicalMessageSource extends MessageSource

interface ApplicationContext extends MessageSource

interface ConfigurableApplicationContext extends ApplicationContext

abstract class AbstractApplicationContext implements ConfigurableApplicationContext {
    - messageSource:MessageSource
}

abstract class AbstractMessageSource implements HierarchicalMessageSource

class StaticMessageSource extends AbstractMessageSource
note top of StaticMessageSource : 多用于测试

abstract class AbstractResourceBasedMessageSource extends AbstractMessageSource

class ResourceBundleMessageSource extends AbstractResourceBasedMessageSource

note bottom of ResourceBundleMessageSource : 常用

class ReloadableResourceBundleMessageSource extends AbstractResourceBasedMessageSource implements ResourceLoaderAware

class DelegatingMessageSource implements HierarchicalMessageSource

note bottom of DelegatingMessageSource : Spring 内部使用该类，启动时\nAbstractApplicationContext\n.initMessageSource 注册该实例

AbstractApplicationContext *--> DelegatingMessageSource : has a >

@enduml
....

== 事件发布

[plantuml, format=svg,align="center",width=100%]
....
@startuml
title <b>Spring容器内事件发布实现类图</b>

abstract class ApplicationEvent extends EventObject
note top of EventObject : JDK内置事件类型
note top of ApplicationEvent : Spring容器内\n自定义事件类型

interface ApplicationListener<E extends ApplicationEvent> extends EventListener {
    + onApplicationEvent(E event):void
}

interface ApplicationEventPublisher {
    + publishEvent(ApplicationEvent event):void
    + publishEvent(Object event):void
}
interface ApplicationContext extends ApplicationEventPublisher

interface ConfigurableApplicationContext extends ApplicationContext

abstract class AbstractApplicationContext implements ConfigurableApplicationContext {
 - applicationEventMulticaster:ApplicationEventMulticaster
}

interface ApplicationEventMulticaster

ApplicationEventMulticaster .right.> ApplicationListener : notify

ApplicationEventMulticaster .up.> ApplicationEvent : publish

ApplicationListener .up.> ApplicationEvent : receive

abstract class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster

class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {
    - taskExecutor:Executor
}

AbstractApplicationContext *--> ApplicationEventMulticaster

@enduml
....

容器启动伊始，就会检查容器内是否存在名称为 `applicationEventMulticaster` 的 `ApplicationEventMulticaster` 对象实例。有的话就使用提供的实现，没有则默认初始化一个 `SimpleApplicationEventMulticaster` 作为将会使用的 `ApplicationEventMulticaster`。

在 `refresh()` 时，先调用 `initMessageSource()` 初始化 `MessageSource` 实例；然后调用 `initApplicationEventMulticaster()` 初始化 `ApplicationEventMulticaster`。

== AOP

[plantuml, format=svg,align="center",width=100%]
....
@startuml
title <b>Pointcut族谱</b>

abstract class DynamicMethodMatcher implements MethodMatcher
abstract class StaticMethodMatcher implements MethodMatcher

Pointcut *.up.> MethodMatcher

abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher implements Pointcut

abstract class DynamicMethodMatcherPointcut extends DynamicMethodMatcher implements Pointcut


class NameMatchMethodPointcut extends StaticMethodMatcherPointcut

abstract class AbstractRegexpMethodPointcut extends StaticMethodMatcherPointcut

class JdkRegexpMethodPointcut extends AbstractRegexpMethodPointcut

@enduml
....


[plantuml, format=svg,align="center",width=100%]
....
@startuml
title <b>常见 Pointcut</b>

interface Pointcut

class NameMatchMethodPointcut

class AnnotationMatchingPointcut

NameMatchMethodPointcut .right.|> Pointcut

AnnotationMatchingPointcut .left.|> Pointcut

class ComposablePointcut implements Pointcut

class JdkRegexpMethodPointcut implements Pointcut

class ControlFlowPointcut implements Pointcut

@enduml
....

`ComposablePointcut` 是 Spring AOP 提供可以进行 `Pointcut` 逻辑运算的 `Pointcut` 实现。

`ControlFlowPointcut` 是在某个类调动时拦截，其他类调用时不调用。每次运行都需要做检查，性能差，慎重选择。



== 第一节

这是一个 Spring 源码分析:

=== Source Doc

truman/src/docs/asciidoc/index.adoc

This is a spring source analysis projects.

== 第二节

[source,java]
----
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, D瓜哥！");
    }
}
----