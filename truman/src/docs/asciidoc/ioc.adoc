[#ioc]
= IoC 的实现原理

== I18n

properties 文件内容是以 ISO-8859-1 编码的。所以，不支持中文，需要把中文进行转码。

[plantuml, format=svg,{image_attr}]
....
@startuml
title <b>MessageSource类层次结构</b>

interface HierarchicalMessageSource extends MessageSource

interface ApplicationContext extends MessageSource

interface ConfigurableApplicationContext extends ApplicationContext

abstract class AbstractApplicationContext implements ConfigurableApplicationContext {
    - messageSource:MessageSource
}

abstract class AbstractMessageSource implements HierarchicalMessageSource

class StaticMessageSource extends AbstractMessageSource
note bottom of StaticMessageSource : 多用于测试

abstract class AbstractResourceBasedMessageSource extends AbstractMessageSource

class ResourceBundleMessageSource extends AbstractResourceBasedMessageSource

note bottom of ResourceBundleMessageSource : 常用

class ReloadableResourceBundleMessageSource extends AbstractResourceBasedMessageSource implements ResourceLoaderAware

class DelegatingMessageSource implements HierarchicalMessageSource

note bottom of DelegatingMessageSource : Spring 内部使用该类，启动时\nAbstractApplicationContext\n.initMessageSource 注册该实例

AbstractApplicationContext *--> DelegatingMessageSource : has a >

@enduml
....

== 事件发布

[plantuml, format=svg,{image_attr}]
....
@startuml
title <b>Spring容器内事件发布实现类图</b>

abstract class ApplicationEvent extends EventObject
note top of EventObject : JDK内置事件类型
note top of ApplicationEvent : Spring容器内\n自定义事件类型

interface ApplicationListener<E extends ApplicationEvent> extends EventListener {
    + onApplicationEvent(E event):void
}

interface ApplicationEventPublisher {
    + publishEvent(ApplicationEvent event):void
    + publishEvent(Object event):void
}
interface ApplicationContext extends ApplicationEventPublisher

interface ConfigurableApplicationContext extends ApplicationContext

abstract class AbstractApplicationContext implements ConfigurableApplicationContext {
 - applicationEventMulticaster:ApplicationEventMulticaster
}

interface ApplicationEventMulticaster

ApplicationEventMulticaster .right.> ApplicationListener : notify

ApplicationEventMulticaster .up.> ApplicationEvent : publish

ApplicationListener .up.> ApplicationEvent : receive

abstract class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster

class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {
    - taskExecutor:Executor
}

AbstractApplicationContext *--> ApplicationEventMulticaster

@enduml
....

容器启动伊始，就会检查容器内是否存在名称为 `applicationEventMulticaster` 的 `ApplicationEventMulticaster` 对象实例。有的话就使用提供的实现，没有则默认初始化一个 `SimpleApplicationEventMulticaster` 作为将会使用的 `ApplicationEventMulticaster`。

在 `refresh()` 时，先调用 `initMessageSource()` 初始化 `MessageSource` 实例；然后调用 `initApplicationEventMulticaster()` 初始化 `ApplicationEventMulticaster`。

Spring 是以 Bean 为核心的。Bean 的配置、配置的读取和解析、以合适的数据结构对 Bean 元数据进行各种操作等。

Spring 是如何解决构造函数依赖的呢？以及如何注入呢？

plantuml::{includedir}/puml/BeanDefinition.puml[{diagram_attr}]

plantuml::{includedir}/puml/BeanFactory.puml[{diagram_attr}]

plantuml::{includedir}/puml/ConfigurationClassPostProcessor.puml[{diagram_attr}]

include::{includedir}/common-interfaces-introduction.adoc[leveloffset=+1]

include::{includedir}/resource.adoc[leveloffset=+1]

include::{includedir}/tag-resolve.adoc[leveloffset=+1]

include::{includedir}/annotations-resolve.adoc[leveloffset=+1]
